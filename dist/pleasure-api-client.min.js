/*!
 * pleasure-api-client v1.0.0-beta
 * (c) 2018-2019 Martin Rafael Gonzalez <tin@devtin.io>
 * Released under the MIT License.
 */
var PleasureApiClient=function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){'use strict';function p(){const a=(process.server&&"3-tier"===process.env.PLEASURE_MODE?process.env.PLEASURE_CLIENT_APP_SERVER_URL:process.env.PLEASURE_CLIENT_APP_URL)||`http://localhost:${3e3}`;return{appURL:a,apiURL:process.env.PLEASURE_CLIENT_API_URL||`${a}${"/api"}`,entitiesUri:process.env.PLEASURE_CLIENT_ENTITIES_URI||"/entities",authEndpoint:process.env.PLEASURE_CLIENT_AUTH_ENDPOINT||"/token",revokeEndpoint:process.env.PLEASURE_CLIENT_REVOKE_ENDPOINT||"/revoke",timeout:15e3}}function q({apiURL:a=s.apiURL,timeout:e=s.timeout}={}){const f=b.create({timeout:e,baseURL:a,paramsSerializer(a){return c.stringify(a,{arrayFormat:"brackets"})},headers:{"X-Pleasure-Client":"1.0.0-beta"}});return f.interceptors.response.use(a=>{const{data:{statusCode:b,data:c,error:d,message:e}}=a||{};if(200===b)return c;throw new r(d,e,b,c)},a=>{const{errors:b,error:c}=d(a,"response.data",{});throw process.env.API_ERROR&&(a&&a.response?console.log(`[api:${a.config.method}(${a.response.status}/${a.response.statusText}) => ${a.config.url}] ${JSON.stringify(a.response.data)}`):console.log(`[api:`,a)),new Error(c||"Unknown error")}),f}b=b&&b.hasOwnProperty("default")?b["default"]:b,c=c&&c.hasOwnProperty("default")?c["default"]:c,d=d&&d.hasOwnProperty("default")?d["default"]:d,e=e&&e.hasOwnProperty("default")?e["default"]:e,f=f&&f.hasOwnProperty("default")?f["default"]:f,g=g&&g.hasOwnProperty("default")?g["default"]:g,h=h&&h.hasOwnProperty("default")?h["default"]:h,i=i&&i.hasOwnProperty("default")?i["default"]:i,j=j&&j.hasOwnProperty("default")?j["default"]:j,k=k&&k.hasOwnProperty("default")?k["default"]:k,m=m&&m.hasOwnProperty("default")?m["default"]:m,n=n&&n.hasOwnProperty("default")?n["default"]:n,o=o&&o.hasOwnProperty("default")?o["default"]:o;class r extends Error{constructor(a,b,c=500,d){super(a),this.message=b,this.code=c,this.data=d}}let s=p();var t=q();let u,v=p();const w={autoConnect:!process.server};class x extends l.EventEmitter{constructor(a,b={}){super(),b=m.all([b,w,b]);const{protocol:c,host:d,pathname:e}=o.parse(a);this._options=b,this._token=null,this._isConnected=!1,this._host=`${c}//${d}`,this._path=`${e}-socket`,this._socket=null,this._binds={error:this._error.bind(this),connect:this._connect.bind(this),disconnect:this._disconnect.bind(this),create:this._proxySocket.bind(this,"create"),update:this._proxySocket.bind(this,"update"),delete:this._proxySocket.bind(this,"delete"),"*":(a,b)=>{this.emit(a,b)}},this._options.autoConnect&&this.connect()}connect(){const a=Object.assign({forceNew:!0,path:this._path},this.token?{transportOptions:{polling:{extraHeaders:{Authorization:`Bearer ${this.token}`}}}}:{});this._socket&&(this._unwireSocket(),this._socket.disconnect()),this._socket=n(this._host,a),this._socket.onevent=x._onEvent(this._socket.onevent),this._wireSocket()}static _onEvent(a){return function(b){const c=b.data||[];a.call(this,b),b.data=["*"].concat(c),a.call(this,b)}}static queryParamEncode(a){return h(a,a=>Array.isArray(a)?a:a instanceof RegExp?{$regex:a.source,$options:a.flags}:"object"==typeof a?y.queryParamEncode(a):a)}_wiring(a,b=!0,c){a.forEach(a=>{this._socket[b?"on":"off"](a,c||this._binds[a])})}_unwireSocket(){this._wiring(Object.keys(this._binds),!1)}_wireSocket(){this._wiring(Object.keys(this._binds))}_proxySocket(a,b){this.emit(a,b)}_error(...a){this.emit("error",...a)}_connect(){this._isConnected=!0,this.emit("connect")}_disconnect(a){this._isConnected=!1,this.emit("disconnect")}get token(){return this._token}set token(a){return this._token=a,this.connect(),a}}class y extends x{constructor({accessToken:a,refreshToken:b,driver:c=q(),config:d=v,reduxOptions:h={}}={}){const{baseURL:j}=c.defaults;super(j,h),this._driver=c,this._accessToken=a,this._refreshToken=b,this._userProfile=null,this._cache=[],this.config=d;const k=a=>{const b={};return(c,...d)=>{const e=i({name:c,args:d});return b[e]?b[e]:b[e]=a(c,...d)}},l=k(a=>{const b={get(b,c){return c in b?b[c].bind(b,a):"toJSON"===c?void 0:b.controller.bind(b,a,f(c))}};return new Proxy(this,b)}),m=k((a,b)=>{function c(c,{entity:d,entry:f}){a!==d||e(f).forEach(a=>{a._id===b&&c(a)})}function d(a){let b;return g(f,({cb:c,bind:d})=>{if(c===a)return b=d,!1}),b||(b=c.bind(null,a),f.push({cb:a,bind:b})),b}const f=[],h={get(c,e){return /^(on|off|once|emit)$/.test(e)?(a,b)=>{c[e](a,d(b))}:e in c?c[e].bind(c,a,b):void 0},apply(){}};return new Proxy(this,h)}),n={get(a,b){const c=b;return"string"!=typeof c||c in a?a[b]:new Proxy(()=>{},{get(a,b){return l(c)[b]},apply:function(a,b,d){return m(c,...d)}})}};return new Proxy(this,n)}async proxyCacheReq({id:a,req:b}){let c;return await j.each(this._cache,async d=>{if(c=await d.req({id:a,req:b}),"undefined"!=typeof c)return!1}),c}async proxyCacheRes({id:a,req:b,res:c}){return await j.each(this._cache,async d=>{await d.res({id:a,req:b,res:c})}),c}async driver(a={}){const b=i(a),c=await this.proxyCacheReq({id:b,req:a});if("undefined"!=typeof c)return c;const d=await this._driver(a);return this.proxyCacheRes({id:b,req:a,res:d}).catch(a=>{console.log(`Proxy cache res error:`,a)}),d}cache(a){this._cache.push(a)}_localLogout(){this.emit("logout",this.userProfile),this._accessToken=null,this._refreshToken=null,this._userProfile=null,this._refreshCredentials()}_refreshCredentials(){return this.token=this._accessToken,this._accessToken?void(this.emit("login",this.userProfile),this._driver.defaults.headers.common.Authorization=`Bearer ${this._accessToken}`):void delete this._driver.defaults.headers.common.Authorization}get userProfile(){return this._userProfile}getSessionProfile(){return this._accessToken?k(this._accessToken):null}async login(a,b={}){this._localLogout();const{accessToken:c,refreshToken:d}=await this.driver({url:`${this.config.authEndpoint}`,method:"post",data:a,params:b});return this._accessToken=c,this._refreshToken=d,this._userProfile=k(c),this._refreshCredentials(),{accessToken:c,refreshToken:d}}async logout(){return await this._driver({url:`${this.config.revokeEndpoint}`,method:"post"}),this._localLogout()}create(a,b,c={}){if(!a||!b)throw new Error(`Provide both entity and entry`);return this.driver({url:`/${a}`,data:b,method:"post",params:c})}getEntities(){return this.driver({url:this.config.entitiesUri})}read(a,b,c,d={}){if(!a||!b)throw new Error(`Provide both entity and id`);const e=[a,b,c].filter(a=>!!a).join("/");return this.driver({url:`/${e}`,params:d})}update(a,b,c,d){if(!a||!b)throw new Error(`Provide both entity and id`);return this.driver({url:`/${a}/${b}`,method:"patch",data:c,params:d})}list(a,b={},c={}){if(!a)throw new Error(`Provide an entity`);return this.driver({url:`/${a}`,params:Object.assign({},c,b)})}delete(a,b,c={}){let d=`/${a}`;return"object"==typeof b&&(Object.assign(c,{id:Array.isArray(b)?e(b):b}),b=null),b&&(d+=`/${b}`),this.driver({url:d,method:"delete",params:y.queryParamEncode(c)})}push(a,b,c,d,e=!1,f={}){if(!a||!b||!c||!d)throw Error(`Provide all 'entity', 'id', 'fieldPath' and 'newEntry'.`);return this.driver({url:`${a}/${b}/${c}`,method:"post",data:{push:d,multiple:e},params:f})}controller(a,b,c=null,d){if(!a||!b)throw Error(`Provide both 'entity' and 'controller'.`);return this.driver({url:`${a}/${b}`,method:null===c?"get":"post",data:c,params:d})}pull(a,b,c,d,e={}){if(!a||!b||!c||!d)throw Error(`Provide all 'entity', 'id', 'fieldPath' and 'pull'.`);return this.driver({url:`${a}/${b}/${c}`,method:"delete",params:Object.assign({},e,{pull:d})})}static instance(a){if(u){if(a)throw new Error(`Opts not accepted since singleton instance is already initialized.`);return u}return u=new y(a),u}}const z=y.instance.bind(y);return a.ApiError=r,a.PleasureApiClient=y,a.apiDriver=t,a.config=s,a.defaultReduxOptions=w,a.getConfig=p,a.getDriver=q,a.instance=z,a}({},axios,qs,get,castArray,kebabCase,forEach,mapValues,objectHash,Promise,jwtDecode,events,merge,io,url);
